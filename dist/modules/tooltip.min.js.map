{"version":3,"sources":["modules/tooltip.js"],"names":["angular","target","provider","placement","this","defaults","templateUrl","template","titleTemplate","trigger","keyboard","html","show","showTimeout","showTimeoutTime","title","type","delay","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","$get","options","$tooltip","extend","config","isString","clearTimeout","hoverState","prefixEvent","hide","isFunction","onShow","leaveAnimateCallback","scope","$emit","destroyTipElement","onHide","_tipToHide","evt","preventDefault","element","triggers","nodeName","split","on","isTouch","toggle","enter","unbindTriggerEvents","length","$onFocusElementMouseDown","off","i","bindKeyboardEvents","tipElement","$onKeyUp","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","$body","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","$element","elRect","getBoundingClientRect","rect","p","width","height","top","left","dimensions","offset","el","scroll","outerDims","isBody","document","documentElement","scrollTop","body","prop","clientWidth","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","parseInt","props","css","right","marginTop","tip","offsetWidth","offsetHeight","delta","getViewportAdjustedDelta","isVertical","arrowDelta","replaceArrow","test","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","findElement","$arrow","timeout","$isShown","tipScope","$destroy","$$phase","$options","$promise","$bsCompiler","compile","$scope","$new","$rootScope","toLowerCase","$id","attr","map","parseFloat","$sce","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","compileData","promise","then","data","tipContainer","init","container","bindTriggerEvents","isElement","destroy","focus","isDefined","onBeforeShow","after","parent","lastChild","display","visibility","link","clonedElement","animation","addClass","prefixClass","safeDigest","version","prepend","$$rAF","$applyPlacement","$animate","enterAnimateCallback","_blur","onBeforeHide","blur","leave","run","autoToken","autoPlace","elementPosition","tipWidth","tipHeight","replace","viewportPosition","originalPlacement","removeClass","tipPosition","getCalculatedOffset","applyPlacement","which","stopPropagation","forEach","directive","$root","$digest","restrict","query","querySelectorAll","isNative","tooltip","transclusion","falseValueRegExp","key","$eval","bsKey","dataTarget","slice","hasOwnProperty","oldValue","$observe","newValue","bsTooltip","bsShow","$watch","match","setViewport","$on"],"mappings":"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","file":"tooltip.min.js","sourcesContent":["'use strict';\n\nangular\n  .module('mgcrea.ngStrap.tooltip', [\n    'mgcrea.ngStrap.core',\n    'mgcrea.ngStrap.helpers.dimensions'\n  ])\n  .provider('$tooltip', function () {\n    var defaults = (this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      showTimeout: false,\n      showTimeoutTime: 50,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      mouseDownPreventDefault: true,\n      mouseDownStopPropagation: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    });\n\n    this.$get = function (\n      $window,\n      $rootScope,\n      $bsCompiler,\n      $q,\n      $templateCache,\n      $http,\n      $animate,\n      $sce,\n      dimensions,\n      $$rAF,\n      $timeout\n    ) {\n      var isNative = /(ip[ao]d|iphone|android)/gi.test(\n        $window.navigator.userAgent\n      );\n      var isTouch = 'createTouch' in $window.document && isNative;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory (element, config) {\n        debugger;\n        var $tooltip = {};\n\n        // Common vars\n        var options = ($tooltip.$options = angular.extend(\n          {},\n          defaults,\n          config\n        ));\n        var promise = ($tooltip.$promise = $bsCompiler.compile(options));\n        var scope = ($tooltip.$scope =\n          (options.scope && options.scope.$new()) || $rootScope.$new());\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay =\n            split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target)\n              ? options.target\n              : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n        };\n\n        $tooltip.destroy = function () {\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n        };\n\n        $tooltip.enter = function () {\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          if (\n            angular.isDefined(options.onBeforeShow) &&\n            angular.isFunction(options.onBeforeShow)\n          ) {\n            options.onBeforeShow($tooltip);\n          }\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (\n            clonedElement,\n            scope\n          ) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({\n            top: '-9999px',\n            left: '-9999px',\n            right: 'auto',\n            display: 'block',\n            visibility: 'hidden'\n          });\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type)\n            tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate\n              .enter(tipElement, parent, after)\n              .then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n          if (\n            angular.isDefined(options.onShow) &&\n            angular.isFunction(options.onShow)\n          ) {\n            options.onShow($tooltip);\n          }\n        }\n\n        $tooltip.leave = function () {\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n          if (\n            angular.isDefined(options.onBeforeHide) &&\n            angular.isFunction(options.onBeforeHide)\n          ) {\n            options.onBeforeHide($tooltip);\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          if (tipElement !== null) {\n            // Support v1.2+ $animate\n            // https://github.com/angular/angular.js/issues/11713\n            if (angular.version.minor <= 2) {\n              $animate.leave(tipElement, leaveAnimateCallback);\n            } else {\n              $animate.leave(tipElement).then(leaveAnimateCallback);\n            }\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          if (\n            angular.isDefined(options.onHide) &&\n            angular.isFunction(options.onHide)\n          ) {\n            options.onHide($tooltip);\n          }\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) {\n            evt.preventDefault();\n          }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          return options.showTimeout ? $timeout(run, options.showTimeoutTime) : run();\n\n          function run () {\n            if (!tipElement) return;\n\n            // Determine if we're doing an auto or normal placement\n            var placement = options.placement;\n            var autoToken = /\\s?auto?\\s?/i;\n            var autoPlace = autoToken.test(placement);\n\n            if (autoPlace) {\n              placement =\n                placement.replace(autoToken, '') || defaults.placement;\n            }\n\n            // Need to add the position class before we get\n            // the offsets\n            tipElement.addClass(options.placement);\n\n            // Get the position of the target element\n            // and the height and width of the tooltip so we can center it.\n            var elementPosition = getPosition();\n            var tipWidth = tipElement.prop('offsetWidth');\n            var tipHeight = tipElement.prop('offsetHeight');\n\n            // Refresh viewport position\n            $tooltip.$viewport =\n              options.viewport &&\n              findElement(options.viewport.selector || options.viewport);\n\n            // If we're auto placing, we need to check the positioning\n            if (autoPlace) {\n              var originalPlacement = placement;\n              var viewportPosition = getPosition($tooltip.$viewport);\n\n              if (\n                /bottom/.test(originalPlacement) &&\n                elementPosition.bottom + tipHeight > viewportPosition.bottom\n              ) {\n                placement = originalPlacement.replace('bottom', 'top');\n              } else if (\n                /top/.test(originalPlacement) &&\n                elementPosition.top - tipHeight < viewportPosition.top\n              ) {\n                placement = originalPlacement.replace('top', 'bottom');\n              }\n\n              if (\n                /left/.test(originalPlacement) &&\n                elementPosition.left - tipWidth < viewportPosition.left\n              ) {\n                placement = placement.replace('left', 'right');\n              } else if (\n                /right/.test(originalPlacement) &&\n                elementPosition.right + tipWidth > viewportPosition.width\n              ) {\n                placement = placement.replace('right', 'left');\n              }\n\n              tipElement.removeClass(originalPlacement).addClass(placement);\n            }\n\n            // Get the tooltip's top and left coordinates to center it with this directive.\n            var tipPosition = getCalculatedOffset(\n              placement,\n              elementPosition,\n              tipWidth,\n              tipHeight\n            );\n            applyPlacement(tipPosition, placement);\n          }\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          if (options.mouseDownPreventDefault) {\n            evt.preventDefault();\n          }\n          if (options.mouseDownStopPropagation) {\n            evt.stopPropagation();\n          }\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(\n                trigger === 'hover' ? 'mouseenter' : 'focus',\n                $tooltip.enter\n              );\n              element.on(\n                trigger === 'hover' ? 'mouseleave' : 'blur',\n                $tooltip.leave\n              );\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(\n                  isTouch ? 'touchstart' : 'mousedown',\n                  $tooltip.$onFocusElementMouseDown\n                );\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(\n                trigger === 'hover' ? 'mouseenter' : 'focus',\n                $tooltip.enter\n              );\n              element.off(\n                trigger === 'hover' ? 'mouseleave' : 'blur',\n                $tooltip.leave\n              );\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(\n                  isTouch ? 'touchstart' : 'mousedown',\n                  $tooltip.$onFocusElementMouseDown\n                );\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents () {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(\n            function () {\n              // Stop propagation when clicking inside tooltip\n              tipElement.on('click', stopEventPropagation);\n\n              // Hide when clicking outside tooltip\n              $body.on('click', $tooltip.hide);\n\n              _autoCloseEventsBinded = true;\n            },\n            0,\n            false\n          );\n        }\n\n        function unbindAutoCloseEvents () {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation (event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition ($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) {\n            // eslint-disable-line\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {\n              width: elRect.right - elRect.left,\n              height: elRect.bottom - elRect.top\n            });\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {\n            scroll: isBody\n              ? document.documentElement.scrollTop || document.body.scrollTop\n              : $element.prop('scrollTop') || 0\n          };\n          var outerDims = isBody\n            ? {\n              width: document.documentElement.clientWidth,\n              height: $window.innerHeight\n            }\n            : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset (\n          placement,\n          position,\n          actualWidth,\n          actualHeight\n        ) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement (offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(\n            tip,\n            angular.extend(\n              {\n                using: function (props) {\n                  tipElement.css({\n                    top: Math.round(props.top) + 'px',\n                    left: Math.round(props.left) + 'px',\n                    right: ''\n                  });\n                }\n              },\n              offset\n            ),\n            0\n          );\n\n          $timeout(function () {\n            // check to see if placing tip in new offset caused the tip to resize itself\n            var actualWidth = tip.offsetWidth;\n            var actualHeight = tip.offsetHeight;\n\n            if (placement === 'top' && actualHeight !== height) {\n              offset.top = offset.top + height - actualHeight;\n            }\n\n            // If it's an exotic placement, exit now instead of\n            // applying a delta and changing the arrow\n            if (/top-left|top-right|bottom-left|bottom-right/.test(placement))\n              return;\n\n            var delta = getViewportAdjustedDelta(\n              placement,\n              offset,\n              actualWidth,\n              actualHeight\n            );\n\n            if (delta.left) {\n              offset.left += delta.left;\n            } else {\n              offset.top += delta.top;\n            }\n\n            dimensions.setOffset(tip, offset);\n\n            if (/top|right|bottom|left/.test(placement)) {\n              var isVertical = /top|bottom/.test(placement);\n              var arrowDelta = isVertical\n                ? delta.left * 2 - width + actualWidth\n                : delta.top * 2 - height + actualHeight;\n              var arrowOffsetPosition = isVertical\n                ? 'offsetWidth'\n                : 'offsetHeight';\n\n              replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n            }\n          }, 50);\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta (\n          placement,\n          position,\n          actualWidth,\n          actualHeight\n        ) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding =\n            (options.viewport && options.viewport.padding) || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset =\n              position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset =\n              position.top +\n              viewportPadding -\n              viewportDimensions.scroll +\n              actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) {\n              // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (\n              bottomEdgeOffset >\n              viewportDimensions.top + viewportDimensions.height\n            ) {\n              // bottom overflow\n              delta.top =\n                viewportDimensions.top +\n                viewportDimensions.height -\n                bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) {\n              // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) {\n              // right overflow\n              delta.left =\n                viewportDimensions.left +\n                viewportDimensions.width -\n                rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow (delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow\n            .css(\n              isHorizontal ? 'left' : 'top',\n              50 * (1 - delta / dimension) + '%'\n            )\n            .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement () {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase ||\n          (scope.$root && scope.$root.$$phase) ||\n          scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n    };\n  })\n  .directive('bsTooltip', function (\n    $window,\n    $location,\n    $sce,\n    $parse,\n    $tooltip,\n    $$rAF\n  ) {\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(\n          [\n            'template',\n            'templateUrl',\n            'controller',\n            'controllerAs',\n            'titleTemplate',\n            'placement',\n            'container',\n            'delay',\n            'trigger',\n            'html',\n            'animation',\n            'backdropAnimation',\n            'type',\n            'customClass',\n            'id',\n            'showTimeout',\n            'showTimeoutTime'\n          ],\n          function (key) {\n            if (angular.isDefined(attr[key])) options[key] = attr[key];\n          }\n        );\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (\n            angular.isDefined(attr[key]) &&\n            falseValueRegExp.test(attr[key])\n          ) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(\n          ['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'],\n          function (key) {\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n            if (angular.isDefined(attr[bsKey])) {\n              options[key] = scope.$eval(attr[bsKey]);\n            }\n          }\n        );\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(\n            attr.bsTooltip,\n            function (newValue, oldValue) {\n              if (angular.isObject(newValue)) {\n                angular.extend(scope, newValue);\n              } else {\n                scope.title = newValue;\n              }\n              if (angular.isDefined(oldValue)) {\n                $$rAF(function () {\n                  if (tooltip) tooltip.$applyPlacement();\n                });\n              }\n            },\n            true\n          );\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue))\n              newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue))\n              newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n      }\n    };\n  });\n"]}